import { fieldSubscriptionItems, formSubscriptionItems, createForm, configOptions } from 'final-form';
import { useRef, useState, useEffect, useCallback } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var all = fieldSubscriptionItems.reduce(function (result, key) {
  result[key] = true;
  return result;
}, {});

var subscriptionToInputs = function subscriptionToInputs(subscription) {
  return fieldSubscriptionItems.map(function (key) {
    return Boolean(subscription[key]);
  });
};

var eventValue = function eventValue(event) {
  if (!event || !event.target) {
    return event;
  } else if (event.target.type === 'checkbox') {
    return event.target.checked;
  }

  return event.target.value;
};

var useField = function useField(name, form, validate, subscription) {
  if (subscription === void 0) {
    subscription = all;
  }

  var autoFocus = useRef(false);
  var validatorRef = useRef(undefined);

  var _useState = useState({}),
      state = _useState[0],
      setState = _useState[1];

  validatorRef.current = validate;
  var deps = subscriptionToInputs(subscription);
  useEffect(function () {
    return form.registerField(name, function (newState) {
      if (autoFocus.current) {
        autoFocus.current = false;
        setTimeout(function () {
          return newState.focus();
        });
      }

      setState(newState);
    }, subscription, validate ? {
      getValidator: function getValidator() {
        return validatorRef.current;
      }
    } : undefined);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [name, form].concat(deps));

  var blur = state.blur,
      change = state.change,
      focus = state.focus,
      value = state.value,
      meta = _objectWithoutPropertiesLoose(state, ["blur", "change", "focus", "value"]);

  delete meta.name; // it's in input

  return {
    input: {
      name: name,
      value: value === undefined ? '' : value,
      onBlur: function onBlur() {
        return state.blur();
      },
      onChange: function onChange(event) {
        return state.change(eventValue(event));
      },
      onFocus: function onFocus() {
        if (state.focus) {
          state.focus();
        } else {
          autoFocus.current = true;
        }
      }
    },
    meta: meta
  };
};

var all$1 = formSubscriptionItems.reduce(function (result, key) {
  result[key] = true;
  return result;
}, {});
/**
 * Converts { active: true, data: false, ... } to `[true, false, false, ...]`.
 */

var subscriptionToInputs$1 = function subscriptionToInputs(subscription) {
  return formSubscriptionItems.map(function (key) {
    return Boolean(subscription[key]);
  });
};

var useFormState = function useFormState(form, subscription) {
  if (subscription === void 0) {
    subscription = all$1;
  }

  var _useState = useState(function () {
    return form.getState();
  }),
      state = _useState[0],
      setState = _useState[1];

  var deps = subscriptionToInputs$1(subscription); // eslint-disable-next-line react-hooks/exhaustive-deps

  useEffect(function () {
    return form.subscribe(setState, subscription);
  }, [form].concat(deps));
  return state;
};

var shallowEqual = function shallowEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (typeof a !== 'object' || !a || typeof b !== 'object' || !b) {
    return false;
  }

  var keysA = Object.keys(a);
  var keysB = Object.keys(b);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(b);

  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key) || a[key] !== b[key]) {
      return false;
    }
  }

  return true;
};

var useMemoOnce = function useMemoOnce(factory) {
  var ref = useRef();

  if (!ref.current) {
    ref.current = factory();
  }

  return ref.current;
};

var useForm = function useForm(_ref) {
  var subscription = _ref.subscription,
      _ref$initialValuesEqu = _ref.initialValuesEqual,
      initialValuesEqual = _ref$initialValuesEqu === void 0 ? shallowEqual : _ref$initialValuesEqu,
      config = _objectWithoutPropertiesLoose(_ref, ["subscription", "initialValuesEqual"]);

  var form = useMemoOnce(function () {
    return createForm(config);
  });
  var prevConfig = useRef(config);
  var state = useFormState(form, subscription);
  var handleSubmit = useCallback(function (event) {
    if (event) {
      if (typeof event.preventDefault === 'function') {
        event.preventDefault();
      }

      if (typeof event.stopPropagation === 'function') {
        event.stopPropagation();
      }
    }

    return form.submit();
  }, [form]);
  useEffect(function () {
    if (config === prevConfig.current) {
      return;
    }

    if (config.initialValues && !initialValuesEqual(config.initialValues, prevConfig.current.initialValues)) {
      form.initialize(config.initialValues);
    }

    configOptions.forEach(function (key) {
      if (key !== 'initialValues' && config[key] !== prevConfig.current[key]) {
        form.setConfig(key, config[key]);
      }
    });
    prevConfig.current = config;
  });
  return _extends({}, state, {
    form: form,
    handleSubmit: handleSubmit
  });
};

export { useField, useForm, useFormState };
